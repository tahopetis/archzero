---

# Appendix E: API Specification (OpenAPI Draft)

**Version:** 1.0.0
**Protocol:** REST + JSON
**Auth:** Bearer Token (JWT)

## 1. Core Resources (Cards)

### 1.1 Unified Upsert (Create or Update)

**`PATCH /api/v1/cards/{id}`**
Handles creating new cards or updating existing ones. Supports updating SQL columns and JSONB attributes in a single atomic request.

* **Parameters:** `id` (UUID, Generated by client or 'new')
* **Request Body:**
```json
{
  "type": "Application",
  "name": "Arc Zero Core",
  "description": "The main EA platform backend.",

  // Tier 1: Strict Fields (SQL)
  "lifecycle": {
    "plan": "2025-01-01",
    "active": "2025-06-01",
    "eol": null
  },
  "quality_score": 95,

  // Tier 2: Flexible Fields (JSONB)
  "attributes": {
    "hosting_type": "Cloud Native",
    "cost_center": "CC-DEV-01",
    "financials": {
      "estimated_cost": 12000,
      "currency": "USD"
    }
  }
}

```


* **Response (200 OK):** Returns the fully persisted Card object including `updated_at`.
* **Response (400 Bad Request):**
```json
{
  "error": "MetamodelViolation",
  "message": "Attribute 'hosting_type' invalid. Allowed: [SaaS, PaaS, IaaS, On-Premise]"
}

```



### 1.2 Bulk Import (Excel/CSV Processor)

**`POST /api/v1/cards/import`**
Processes raw tabular data.

* **Request Body (Multipart/Form-Data):** `file` (.xlsx or .csv)
* **Response (200 OK - Preview Mode):**
Returns a mapping guess for user confirmation before committing.
```json
{
  "detected_rows": 150,
  "mappings": [
    { "csv_header": "App Name", "target_field": "name", "confidence": 0.99 },
    { "csv_header": "Owner", "target_field": "attributes.owner", "confidence": 0.8 }
  ]
}

```



---

## 2. Graph & Visualizations

### 2.1 The "Time Machine" Traversal

**`POST /api/v1/graph/traverse`**
Fetches the node/edge structure for visualizations (Landscape, Matrix).

* **Request Body:**
```json
{
  "root_type": "BusinessCapability",
  "depth": 3,
  "target_date": "2026-06-01", // Future State Query
  "relations": ["PARENT_OF", "SUPPORTS"], // Filter specific edge types
  "filter": {
    "attributes.hosting_type": "On-Premise" // SQL/JSONB Filter applied to nodes
  }
}

```


* **Response (200 OK):** Standard Graph JSON format (compatible with `react-force-graph` or D3).
```json
{
  "nodes": [
    { "id": "uuid-1", "name": "Sales", "group": "Capability" },
    { "id": "uuid-2", "name": "Salesforce", "group": "Application", "color": "#FF0000" } // Color computed by backend
  ],
  "links": [
    { "source": "uuid-2", "target": "uuid-1", "type": "SUPPORTS" }
  ]
}

```



### 2.2 TCO Cost Rollup

**`GET /api/v1/cards/{id}/tco`**
Triggers the recursive cost calculation engine for a specific node.

* **Response (200 OK):**
```json
{
  "node_id": "uuid-app-1",
  "total_tco": 55000,
  "breakdown": [
    { "source": "Direct License", "amount": 25000 },
    { "source": "Inherited (Database Cluster)", "amount": 20000, "allocation_method": "Percentage (80%)" },
    { "source": "Inherited (AWS Infrastructure)", "amount": 10000 }
  ]
}

```



---

## 3. Configuration & Metadata

### 3.1 Fetch Metamodel Rules

**`GET /api/v1/config/metamodel/{card_type}`**
Used by the Frontend to generate dynamic forms.

* **Response (200 OK):**
```json
[
  {
    "key": "hosting_type",
    "label": "Hosting Strategy",
    "widget": "select",
    "options": ["SaaS", "PaaS", "IaaS", "On-Premise"],
    "required": true
  },
  {
    "key": "cost_center",
    "label": "Cost Center Code",
    "widget": "text",
    "regex": "^[A-Z]{2}-\\d{4}$"
  }
]

```



### 3.2 Scoring Profile Execution

**`POST /api/v1/intelligence/assess`**
Runs the BIA or 6R logic against a hypothetical payload (used for "What-If" analysis in the UI).

* **Request:**
```json
{
  "profile_id": "profile-cloud-first-v1",
  "inputs": {
    "technical_fit": 2,
    "business_value": 4
  }
}

```


* **Response:**
```json
{
  "recommended_strategy": "REFACTOR",
  "reasoning": "High Business Value but Low Technical Fit triggers Modernization rule."
}

```



---

## 4. Implementation Guidelines

1. **Strict Typing:** The Rust backend must deserialize the `attributes` JSONB into specific Structs where possible, falling back to `serde_json::Value` only for truly custom fields.
2. **Graph Performance:** The `/traverse` endpoint should use **Neo4j Cypher** directly for the query, but enrich the Node data (Names, Costs) by fetching from **Postgres** (using the UUIDs returned by Neo4j) to avoid storing duplicate data in the graph.
